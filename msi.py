import sys
import tokenize
from itertools import groupby

import numpy as np


class FormatError(IOError):
    pass


class Lattice(object):

    def __init__(self, matrix: np.ndarray):
        """
        Initialize of Lattice class

        Args:
            matrix (np.ndarray): use a (3x3) np.ndarray matrix to initialize the Lattice
        """
        self.matrix = matrix

    def __eq__(self, other):
        return np.all(self.matrix == other.matrix)

    def __hash__(self):
        return hash(self.volume)

    def __repr__(self):
        return f"{self.matrix}"

    @property
    def length(self) -> np.ndarray:
        """
        Calculate the lattice length

        Returns:
            length (np.ndarray): store the length, shape = (3x1)
        """
        return np.power(np.sum(np.power(self.matrix, 2), axis=1), 0.5)

    @property
    def angle(self) -> np.ndarray:
        """
        Calculate the lattice angle

        Returns:
            angle (np.ndarray): store the angle, shape = (3x1)
        """
        alpha = np.arccos(np.dot(self.matrix[1], self.matrix[2]) / (self.length[1] * self.length[2])) * 180 / np.pi
        beta = np.arccos(np.dot(self.matrix[0], self.matrix[2]) / (self.length[0] * self.length[2])) * 180 / np.pi
        gamma = np.arccos(np.dot(self.matrix[0], self.matrix[1]) / (self.length[0] * self.length[1])) * 180 / np.pi
        return np.array([alpha, beta, gamma])

    @property
    def volume(self) -> float:
        """
        Calculate the lattice volume

        Returns:
            volume (float): store the volume
        """
        return np.linalg.det(self.matrix)

    @property
    def inverse(self) -> np.ndarray:
        """
        Calculate the inverse matrix of lattice

        Returns:
            inverse (np.ndarray): store the inverse matrix
        """
        return np.linalg.inv(self.matrix)

    @staticmethod
    def from_string(string):
        """
        Construct a Lattice instance from string

        Args:
            string (List[str]): three-line <string>

                Examples
                ---------
                >>> string
                array([[  7.707464,  0.000000,  0.000000],
                         -3.853732,  6.674860,  0.000000],
                          0.000000,  0.000000, 28.319031]])

        Returns:
            lattice (Lattice): Lattice instance
        """
        matrix = np.array([[float(ii) for ii in item.split()[:3]] for item in string.splitlines()])
        return Lattice(matrix)

    @property
    def strings(self) -> str:
        """
        Transform a Lattice instance to string

        Returns:
            strings (str): Lattice instance in string format
        """
        return "".join([" ".join([f"{ii:>9.6f}" for ii in item]) + "\n" for item in self.matrix])


class MSIAtom(object):
    """
    Atom class defined for *.msi file

    Attributes:
        formula (str): element formula, e.g. "C" for `Element C`
        coord (np.array): atom coordinate, e.g. array([0., 0., 0.])
    """

    def __init__(self):
        self.formula = None
        self.coord = []

    def __repr__(self):
        return f"<{self.formula} {self.coord}>"


class MSIModel(object):
    """
    Model class defined for *.msi file

    Attributes:
        name (str): model name, e.g., "beta-A"
        space_group (str): Space Group of model, only support "P1"
        lattice (np.array): lattice matrix in <np.array> format
        atoms (list): list of <MSIAtom class>

        Example
        =========

        >>> lattice
            array([12.470000  0.000000  0.000000]
                  [0.000000  12.470000  0.000000]
                  [0.000000   0.000000 26.331000])
    """

    def __init__(self):
        self.name = None
        self.space_group = None
        self.lattice = None
        self.atoms = []

    def write_to_POSCAR(self):
        """
        Export the model to POSCAR file

        Return:
            `POSCAR` file
        """
        lattice_strings = "".join([" ".join([f"{ii:>9.6f}" for ii in item]) + "\n" for item in self.lattice])
        formulas = [atom.formula for atom in self.atoms]
        elements = [(key, str(len(list(group)))) for key, group in groupby(formulas)]
        element_name, element_count = list(map(list, zip(*elements)))
        element_name, element_count = " ".join(element_name), " ".join(element_count)
        coords = "\n".join([" ".join([f"{item:15.12f}" for item in atom.coord]) for atom in self.atoms])
        with open("POSCAR", "w") as f:
            f.write(f"AutoGenerated: {' '.join([f'{element[0]} {element[1]}' for element in elements])}\n")
            f.write(f"1.00000 \n")
            f.write(f'{lattice_strings}')
            f.write(f"{element_name}\n")
            f.write(f"{element_count}\n")
            f.write("Cartesian \n")
            f.write(coords)
            f.write("\n\n")

    def write_to_cif(self):
        """
        Export the model to cif file

        Return:
            `structure.cif` file
        """

        lattice_strings = "".join([" ".join([f"{ii:>9.6f}" for ii in item]) + "\n" for item in self.lattice])
        lattice = Lattice.from_string(lattice_strings)
        formulas = [atom.formula for atom in self.atoms]
        elements = [(key, str(len(list(group)))) for key, group in groupby(formulas)]
        cart_coords = np.array([[item for item in atom.coord] for atom in self.atoms])
        frac_coords = np.dot(cart_coords, lattice.inverse)
        with open("structure.cif", "w") as f:
            f.write(f"# CIF file AutoGenerated \n")
            f.write(f"data_I \n")
            POSCAR_title = f"AutoGenerated: {' '.join([f'{element[0]} {element[1]}' for element in elements])}"
            f.write(f"_chemical_name_common '{POSCAR_title}' \n")
            f.write(f"_cell_length_a {lattice.length[0]:.3f} \n")
            f.write(f"_cell_length_b {lattice.length[1]:.3f} \n")
            f.write(f"_cell_length_c {lattice.length[2]:.3f} \n")
            f.write(f"_cell_angle_alpha {lattice.angle[0]:.2f} \n")
            f.write(f"_cell_angle_beta {lattice.angle[1]:.2f} \n")
            f.write(f"_cell_angle_gamma {lattice.angle[2]:.2f} \n")
            f.write(f"_space_group_name_H-M_alt 'P 1' \n")
            f.write(f"_space_group_name_Hall 'P 1' \n")
            f.write(f"loop_ \n")
            f.write(f"loop_ \n")
            f.write(f"    _symmetry_equiv_pos_as_xyz \n")
            f.write(f"    x,y,z \n")
            f.write(f"loop_ \n")
            f.write(f"    _atom_site_label \n")
            f.write(f"    _atom_site_type_symbol \n")
            f.write(f"    _atom_site_fract_x \n")
            f.write(f"    _atom_site_fract_y \n")
            f.write(f"    _atom_site_fract_z \n")
            f.write(f"    _atom_site_occupancy \n")
            for (index, formula), coord in zip(enumerate(formulas), frac_coords):
                f.write(f"    {formula}{index}\t{formula}\t{coord[0]:.5f}\t{coord[1]:.5f}\t{coord[2]:.5f}\t1.000 \n")


class MSIParser(object):
    """
    Parser class defined for *.msi file
    """

    def __init__(self, file):
        """
        Initialize the MSIParser

        Args:
            file: path of *.msi file
        """
        self.file = file
        self._tokens = self.__initialize_tokens()
        self.model_stack = []
        self.atom_stack = []
        self.attr_stack = []
        self.array_stack = []

    def __initialize_tokens(self):
        """
        Use tokenize to obtain the tokens
        """
        tokens_list = []
        with tokenize.open(self.file) as f:
            tokens = tokenize.generate_tokens(f.readline)
            for token in tokens:
                tokens_list.append(token)
        return tokens_list

    def parse(self):
        """
        Main parse func

        Returns:
            <MSIModel class> instance
        """
        minus_symbol = None
        lattice = []
        for index, token in enumerate(self._tokens):
            if token.type == 54 and token.string == "(":  # Begin token
                if token.line == '(1 Model\n':  # Root token
                    self.model_stack.append(token)
                    model = MSIModel()
                elif self._tokens[index + 1].string == "A":  # Attr token
                    self.attr_stack.append(token)
                elif self._tokens[index + 2].string == "Atom":  # Atom token
                    self.atom_stack.append(token)
                    atom = MSIAtom()
                    coord = []
                elif self._tokens[index - 1].string in ["A3", "B3", "C3", "XYZ"]:  # Array token
                    self.array_stack.append(token)
            elif token.type == 54 and token.string == ")":  # End token
                if len(self.model_stack):
                    if len(self.attr_stack):
                        self.attr_stack.pop()
                    elif len(self.array_stack):
                        self.array_stack.pop()
                    elif len(self.atom_stack):
                        self.atom_stack.pop()
                        if getattr(atom, "formula") is not None:
                            if not len(coord):
                                coord = [0., 0., 0.]  # fix bug: (0,0,0) coord not display in *.msi file
                            atom.coord = np.array(coord)
                            model.atoms.append(atom)
                else:
                    raise FormatError("*.msi file format error and I can't parse it")
            else:  # Content token
                if len(self.array_stack):  # parse `** XYZ ()` or `** A3 ()`
                    string_value = token.string
                    if token.type == 54:  # fix bug: '-' is considered as a delimiter
                        minus_symbol = token.string
                    else:
                        if minus_symbol is not None:
                            string_value = minus_symbol + string_value
                            minus_symbol = None

                        if not len(self.atom_stack):
                            lattice.append(float(string_value))  # parse lattice
                        else:
                            coord.append(float(string_value))
                if len(self.attr_stack):  # parse `(A ** )`
                    if not len(self.atom_stack):
                        if index + 2 < len(self._tokens):
                            if self._tokens[index + 2].string == "Label":
                                model.name = self._tokens[index + 3].string
                            elif self._tokens[index + 2].string == "SpaceGroup":
                                if self._tokens[index + 3].string != '"1 1"':
                                    raise FormatError("Only supported the P1 symmetry")
                                else:
                                    model.space_group = "P1"
                    else:
                        if self._tokens[index + 2].string == "ACL":
                            atom.formula = self._tokens[index + 3].string.split()[-1].replace('"', '')

        model.lattice = np.array(lattice).reshape((3, 3))  # transform to np.array format
        model.atoms = sorted(model.atoms, key=lambda x: x.formula)  # sort atoms according to the formula key

        return model


def main():
    parser = MSIParser(sys.argv[1])
    model = parser.parse()
    if sys.argv[2] == "POSCAR":
        model.write_to_POSCAR()
    elif sys.argv[2] == "cif":
        model.write_to_cif()
    else:
        model.write_to_POSCAR()


if __name__ == '__main__':
    # parser = MSIParser(sys.argv[1])
    # parser = MSIParser("Structures/ceramics/C_amorphous.msi")
    # parser = MSIParser("Structures/ceramics/BaTiO3.msi")
    # model = parser.parse()
    # model.write_to_POSCAR()
    # model.write_to_cif()
    # print()
    main()
